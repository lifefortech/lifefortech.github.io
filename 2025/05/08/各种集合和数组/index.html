<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>各种集合和数组 | Welcome To LifeTech's Blog</title><meta name="keywords" content="Rust基础知识"><meta name="author" content="Jackey Zhou"><meta name="copyright" content="Jackey Zhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="各种集合和数组"><meta name="application-name" content="各种集合和数组"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="各种集合和数组"><meta property="og:url" content="http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/index.html"><meta property="og:site_name" content="Welcome To LifeTech's Blog"><meta property="og:description" content="1. Vec&amp;lt;T&amp;gt; (动态数组&amp;#x2F;向量 Vector) 概要与用途: Vec&amp;lt;T&amp;gt; (通常称为vector) 是一个可增长的、在堆上分配内存的连续数组。它是Rust中最常用的集合类型之一，用于存储一系列相同类型的元素。当你需要在运行时动态添加或删除元素，并且希望通过索"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Jackey Zhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1. Vec&amp;lt;T&amp;gt; (动态数组&amp;#x2F;向量 Vector) 概要与用途: Vec&amp;lt;T&amp;gt; (通常称为vector) 是一个可增长的、在堆上分配内存的连续数组。它是Rust中最常用的集合类型之一，用于存储一系列相同类型的元素。当你需要在运行时动态添加或删除元素，并且希望通过索"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jackey Zhou","link":"链接: ","source":"来源: Welcome To LifeTech's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Welcome To LifeTech's Blog',
  title: '各种集合和数组',
  postAI: '',
  pageFillDescription: '1. VecltTgt (动态数组x2F向量 Vector), 2. VecDequeltTgt (双端队列 Vector Deque), 3. LinkedListltTgt (双向链表), 4. HashMapltK Vgt (哈希映射), 5. BTreeMapltK Vgt (B树映射), 6. HashSetltTgt (哈希集合), 7. BTreeSetltTgt (B树集合), 8. String (字符串), 9. BinaryHeapltTgt (二叉堆 x2F 优先队列)动态数组向量概要与用途通常称为是一个可增长的在堆上分配内存的连续数组它是中最常用的集合类型之一用于存储一系列相同类型的元素当你需要在运行时动态添加或删除元素并且希望通过索引快速访问元素时是一个很好的选择内部实现由三部分组成一个指向堆上分配的连续内存块的指针该内存块的总容量以及当前存储的元素数量当元素数量超过容量时会重新分配一个更大的内存块并将现有元素复制过去这可能是一个耗时的操作所有权本身不是类型当被赋值或传递给函数时所有权会转移如果其元素类型是则访问元素时会得到副本如果不是则按值迭代会移动元素所有权主要操作与创建创建一个空的创建一个指定初始容量的空宏创建并初始化一个例如添加元素在末尾添加一个元素在指定索引处插入一个元素后续元素向后移动删除元素移除并返回末尾的元素如果存在移除并返回指定索引处的元素后续元素向前移动移除所有元素访问元素索引访问如果索引越界会返回指定索引处元素的不可变引用如果存在返回指定索引处元素的可变引用如果存在长度与容量返回当前元素数量返回当前分配的内存能容纳的元素数量检查是否为空迭代性能特性末尾添加删除平均除非需要重分配此时为按索引访问修改中间插入删除因为需要移动元素示例双端队列概要与用途是一个基于环形缓冲区实现的双端队列它允许在队列的头部和尾部进行高效的添加和删除操作适用于需要同时从两端操作序列的场景例如实现队列或栈内部实现使用环形缓冲区数据在逻辑上是连续的但在物理内存中可能不是从零地址开始这使得在两端添加删除元素时无需移动其他元素除非达到容量所有权与类似本身不是主要操作与创建添加元素在头部添加元素在尾部添加元素类似删除元素从头部移除并返回元素从尾部移除并返回元素类似访问元素索引访问也支持但索引是相对于当前头部的长度与容量迭代性能特性头部尾部添加删除平均除非需要重分配按索引访问中间插入删除示例双向链表概要与用途是一个双向链表它的每个元素都存储指向前一个和后一个元素的指针与或不同它在内存中不是连续存储的在现代中由于其缓存性能较差以及相对复杂和通常是更好的选择即使是在需要频繁在中间插入删除元素的场景所有权本身不是主要操作与创建添加元素删除元素长度迭代分割与合并性能特性头部尾部添加删除在已知位置通过插入删除按索引访问搜索缓存局部性差可能导致实际性能不如基于数组的结构示例注意的在某些操作上不如或直观特别是涉及修改链表中间部分时哈希映射概要与用途存储键值对它使用哈希表实现提供平均时间的插入删除和查找操作键必须实现和中的元素是无序的内部实现基于哈希表使用开放定址法或链地址法来解决哈希冲突默认使用哈希算法可以抵抗哈希洪水攻击所有权本身不是键和值的所有权会移入主要操作与创建插入更新如果键已存在返回旧值获取删除检查存在性长度迭代产生产生产生产生产生提供更复杂的原子操作如等性能特性插入删除查找平均最坏哈希冲突严重时键的要求类型必须实现和示例使用更新或插入树映射概要与用途也存储键值对但它使用树实现与不同中的键值对是按键的顺序排序的键必须实现通常也需要和内部实现基于树这是一种自平衡树结构可以保持数据排序并允许高效的范围查询所有权本身不是主要操作与与类似但迭代器会按键的顺序产生元素获取指定范围内的键值对性能特性插入删除查找比慢但提供了有序遍历和更好的最坏情况性能由于数据在内存中更有序有时缓存性能可能比好特别是在迭代时键的要求类型必须实现示例元素会按键排序哈希集合概要与用途存储唯一的元素类似于数学中的集合它使用哈希表实现其元素是无序的值必须实现和内部实现通常基于实现所有权本身不是主要操作与创建添加如果值已存在则返回否则返回删除如果值存在并被删除则返回检查存在性集合运算长度迭代性能特性与类似平均的插入删除查找值的要求类型必须实现和示例顺序不保证或其他组合树集合概要与用途也存储唯一的元素但它使用树实现因此元素是按顺序排序的值必须实现内部实现通常基于实现所有权本身不是主要操作与与类似但迭代器会按顺序产生元素也支持集合运算性能特性与类似的插入删除查找值的要求类型必须实现示例元素会按顺序输出字符串概要与用途是一个可增长的编码的在堆上分配的字符串类型它是中处理文本数据的主要方式内部实现内部本质上是一个但它保证了其内容始终是有效的编码所有权不是赋值或函数传递会导致所有权转移使用可以创建副本主要操作与非常多这里列举一些创建方法追加或操作符通常与配合修改访问字节长度迭代字符迭代字节获取子切片切片可以创建类型的字符串切片性能特性许多操作与类似字符操作可能比字符操作复杂示例你好你好二叉堆优先队列概要与用途是一个基于二叉堆实现的优先队列默认情况下它是一个最大堆即操作总是返回最大的元素元素必须实现内部实现通常使用数组来隐式表示堆结构所有权本身不是主要操作与创建添加获取删除最大元素查看最大元素长度迭代消耗堆并返回排序的迭代器性能特性值的要求类型必须实现以及通常也需要示例顺序选择合适的集合类型取决于你的具体需求如是否需要排序是否需要唯一元素访问模式性能要求等的模块提供了丰富且高效的工具来满足各种场景',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-08 01:57:59',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Welcome To LifeTech's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSharp%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">CSharp学习<sup>3</sup></a><a href="/tags/IDE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 1.05rem;">IDE常用快捷键<sup>2</sup></a><a href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">Rust基础知识<sup>21</sup></a><a href="/tags/docker%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">docker学习<sup>1</sup></a><a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">hexo博客常见命令<sup>1</sup></a><a href="/tags/xmake%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">xmake学习<sup>3</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">个人学习<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 1.05rem;">数据分析<sup>1</sup></a><a href="/tags/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/" style="font-size: 1.05rem;">无线调试<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">系统常用命令<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 1.05rem;">系统常用快捷键<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Rust基础知识</span></a></span></div></div><h1 class="post-title" itemprop="name headline">各种集合和数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-07T17:26:55.000Z" title="发表于 2025-05-08 01:26:55">2025-05-08</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-07T17:57:59.720Z" title="更新于 2025-05-08 01:57:59">2025-05-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为无锡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>无锡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/"><header><a href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url">Rust基础知识</a><h1 id="CrawlerTitle" itemprop="name headline">各种集合和数组</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jackey Zhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-07T17:26:55.000Z" title="发表于 2025-05-08 01:26:55">2025-05-08</time><time itemprop="dateCreated datePublished" datetime="2025-05-07T17:57:59.720Z" title="更新于 2025-05-08 01:57:59">2025-05-08</time></header><h3 id="1-Vec-动态数组-向量-Vector"><a href="#1-Vec-动态数组-向量-Vector" class="headerlink" title="1. Vec&lt;T&gt; (动态数组&#x2F;向量 Vector)"></a>1. <code>Vec&lt;T&gt;</code> (动态数组&#x2F;向量 Vector)</h3><ul>
<li><strong>概要与用途</strong>: <code>Vec&lt;T&gt;</code> (通常称为vector) 是一个可增长的、在堆上分配内存的连续数组。它是Rust中最常用的集合类型之一，用于存储一系列相同类型的元素。当你需要在运行时动态添加或删除元素，并且希望通过索引快速访问元素时，<code>Vec</code> 是一个很好的选择。</li>
<li><strong>内部实现</strong>: <code>Vec&lt;T&gt;</code> 由三部分组成：一个指向堆上分配的连续内存块的指针、该内存块的总容量 (capacity)、以及当前存储的元素数量 (length)。当元素数量超过容量时，<code>Vec</code> 会重新分配一个更大的内存块，并将现有元素复制过去（这可能是一个耗时的操作）。</li>
<li><strong>所有权</strong>: <code>Vec&lt;T&gt;</code> 本身不是 <code>Copy</code> 类型。当 <code>Vec</code> 被赋值或传递给函数时，所有权会转移。如果其元素类型 <code>T</code> 是 <code>Copy</code>，则访问元素时会得到副本；如果 <code>T</code> 不是 <code>Copy</code>，则按值迭代会移动元素所有权。</li>
<li><strong>主要操作与API</strong>:<ul>
<li><strong>创建</strong>:<ul>
<li><code>Vec::new()</code>: 创建一个空的 <code>Vec</code>。</li>
<li><code>Vec::with_capacity(capacity: usize)</code>: 创建一个指定初始容量的空 <code>Vec</code>。</li>
<li><code>vec![...]</code> (宏): 创建并初始化一个 <code>Vec</code>。例如 <code>let v = vec![1, 2, 3];</code></li>
</ul>
</li>
<li><strong>添加元素</strong>:<ul>
<li><code>push(value: T)</code>: 在末尾添加一个元素。</li>
<li><code>insert(index: usize, element: T)</code>: 在指定索引处插入一个元素，后续元素向后移动。</li>
</ul>
</li>
<li><strong>删除元素</strong>:<ul>
<li><code>pop() -&gt; Option&lt;T&gt;</code>: 移除并返回末尾的元素 (如果存在)。</li>
<li><code>remove(index: usize) -&gt; T</code>: 移除并返回指定索引处的元素，后续元素向前移动。</li>
<li><code>clear()</code>: 移除所有元素。</li>
</ul>
</li>
<li><strong>访问元素</strong>:<ul>
<li>索引访问 <code>[]</code>: <code>v[index]</code> (如果索引越界会 panic)。</li>
<li><code>get(index: usize) -&gt; Option&lt;&amp;T&gt;</code>: 返回指定索引处元素的不可变引用 (如果存在)。</li>
<li><code>get_mut(index: usize) -&gt; Option&lt;&amp;mut T&gt;</code>: 返回指定索引处元素的可变引用 (如果存在)。</li>
<li><code>first() -&gt; Option&lt;&amp;T&gt;</code>, <code>last() -&gt; Option&lt;&amp;T&gt;</code></li>
</ul>
</li>
<li><strong>长度与容量</strong>:<ul>
<li><code>len() -&gt; usize</code>: 返回当前元素数量。</li>
<li><code>capacity() -&gt; usize</code>: 返回当前分配的内存能容纳的元素数量。</li>
<li><code>is_empty() -&gt; bool</code>: 检查是否为空。</li>
</ul>
</li>
<li><strong>迭代</strong>: <code>iter()</code>, <code>iter_mut()</code>, <code>into_iter()</code>。</li>
</ul>
</li>
<li><strong>性能特性</strong>:<ul>
<li>末尾添加&#x2F;删除 (<code>push</code>, <code>pop</code>): 平均 O(1) (除非需要重分配，此时为 O(n))。</li>
<li>按索引访问&#x2F;修改: O(1)。</li>
<li>中间插入&#x2F;删除 (<code>insert</code>, <code>remove</code>): O(n) (因为需要移动元素)。</li>
</ul>
</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="title function_ invoke__">push</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Vector: &#123;:?&#125;&quot;</span>, v); <span class="comment">// Vector: [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(last_val) = v.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Popped: &#123;&#125;&quot;</span>, last_val); <span class="comment">// Popped: 30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Element at index 0: &#123;&#125;&quot;</span>, v[<span class="number">0</span>]); <span class="comment">// Element at index 0: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">x</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Item: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-VecDeque-双端队列-Vector-Deque"><a href="#2-VecDeque-双端队列-Vector-Deque" class="headerlink" title="2. VecDeque&lt;T&gt; (双端队列 Vector Deque)"></a>2. <code>VecDeque&lt;T&gt;</code> (双端队列 Vector Deque)</h3><ul>
<li><strong>概要与用途</strong>: <code>VecDeque&lt;T&gt;</code> 是一个基于环形缓冲区 (ring buffer) 实现的双端队列。它允许在队列的头部和尾部进行高效的添加和删除操作。适用于需要同时从两端操作序列的场景，例如实现队列 (FIFO) 或栈 (LIFO)。</li>
<li><strong>内部实现</strong>: 使用环形缓冲区，数据在逻辑上是连续的，但在物理内存中可能不是从零地址开始。这使得在两端添加&#x2F;删除元素时无需移动其他元素（除非达到容量）。</li>
<li><strong>所有权</strong>: 与 <code>Vec&lt;T&gt;</code> 类似，本身不是 <code>Copy</code>。</li>
<li><strong>主要操作与API</strong>:<ul>
<li><strong>创建</strong>: <code>VecDeque::new()</code>, <code>VecDeque::with_capacity(capacity: usize)</code>。</li>
<li><strong>添加元素</strong>:<ul>
<li><code>push_front(value: T)</code>: 在头部添加元素。</li>
<li><code>push_back(value: T)</code>: 在尾部添加元素 (类似 <code>Vec::push</code>)。</li>
</ul>
</li>
<li><strong>删除元素</strong>:<ul>
<li><code>pop_front() -&gt; Option&lt;T&gt;</code>: 从头部移除并返回元素。</li>
<li><code>pop_back() -&gt; Option&lt;T&gt;</code>: 从尾部移除并返回元素 (类似 <code>Vec::pop</code>)。</li>
</ul>
</li>
<li><strong>访问元素</strong>:<ul>
<li><code>get(index: usize) -&gt; Option&lt;&amp;T&gt;</code>, <code>get_mut(index: usize) -&gt; Option&lt;&amp;mut T&gt;</code>。</li>
<li>索引访问 <code>[]</code> 也支持，但索引是相对于当前头部的。</li>
<li><code>front() -&gt; Option&lt;&amp;T&gt;</code>, <code>back() -&gt; Option&lt;&amp;T&gt;</code>。</li>
</ul>
</li>
<li><strong>长度与容量</strong>: <code>len()</code>, <code>capacity()</code>, <code>is_empty()</code>。</li>
<li><strong>迭代</strong>: <code>iter()</code>, <code>iter_mut()</code>, <code>into_iter()</code>。</li>
</ul>
</li>
<li><strong>性能特性</strong>:<ul>
<li>头部&#x2F;尾部添加&#x2F;删除 (<code>push_front</code>, <code>pop_front</code>, <code>push_back</code>, <code>pop_back</code>): 平均 O(1) (除非需要重分配)。</li>
<li>按索引访问: O(1)。</li>
<li>中间插入&#x2F;删除: O(n)。</li>
</ul>
</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">deque</span>: VecDeque&lt;<span class="type">i32</span>&gt; = VecDeque::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    deque.<span class="title function_ invoke__">push_back</span>(<span class="number">1</span>);    <span class="comment">// [1]</span></span><br><span class="line">    deque.<span class="title function_ invoke__">push_front</span>(<span class="number">0</span>);   <span class="comment">// [0, 1]</span></span><br><span class="line">    deque.<span class="title function_ invoke__">push_back</span>(<span class="number">2</span>);    <span class="comment">// [0, 1, 2]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Deque: &#123;:?&#125;&quot;</span>, deque);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(front_val) = deque.<span class="title function_ invoke__">pop_front</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Popped from front: &#123;&#125;&quot;</span>, front_val); <span class="comment">// Popped from front: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Deque after pop_front: &#123;:?&#125;&quot;</span>, deque); <span class="comment">// Deque after pop_front: [1, 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-LinkedList-双向链表"><a href="#3-LinkedList-双向链表" class="headerlink" title="3. LinkedList&lt;T&gt; (双向链表)"></a>3. <code>LinkedList&lt;T&gt;</code> (双向链表)</h3><ul>
<li><strong>概要与用途</strong>: <code>LinkedList&lt;T&gt;</code> 是一个双向链表。它的每个元素都存储指向前一个和后一个元素的指针。与 <code>Vec</code> 或 <code>VecDeque</code> 不同，它在内存中不是连续存储的。在现代Rust中，由于其缓存性能较差以及API相对复杂，<code>Vec</code> 和 <code>VecDeque</code> 通常是更好的选择，即使是在需要频繁在中间插入&#x2F;删除元素的场景。</li>
<li><strong>所有权</strong>: 本身不是 <code>Copy</code>。</li>
<li><strong>主要操作与API</strong>:<ul>
<li><strong>创建</strong>: <code>LinkedList::new()</code>.</li>
<li><strong>添加元素</strong>: <code>push_front(value: T)</code>, <code>push_back(value: T)</code>.</li>
<li><strong>删除元素</strong>: <code>pop_front() -&gt; Option&lt;T&gt;</code>, <code>pop_back() -&gt; Option&lt;T)</code>.</li>
<li><strong>长度</strong>: <code>len()</code>, <code>is_empty()</code>.</li>
<li><strong>迭代</strong>: <code>iter()</code>, <code>iter_mut()</code>, <code>into_iter()</code>.</li>
<li><strong>分割与合并</strong>: <code>split_off(at: usize) -&gt; LinkedList&lt;T&gt;</code>, <code>append(other: &amp;mut LinkedList&lt;T&gt;)</code>.</li>
</ul>
</li>
<li><strong>性能特性</strong>:<ul>
<li>头部&#x2F;尾部添加&#x2F;删除: O(1)。</li>
<li>在已知位置（通过Cursor API）插入&#x2F;删除: O(1)。</li>
<li>按索引访问&#x2F;搜索: O(n)。</li>
<li>缓存局部性差，可能导致实际性能不如基于数组的结构。</li>
</ul>
</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span>: LinkedList&lt;<span class="type">String</span>&gt; = LinkedList::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    list.<span class="title function_ invoke__">push_back</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    list.<span class="title function_ invoke__">push_front</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LinkedList: &#123;:?&#125;&quot;</span>, list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Item: &#123;&#125;&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <strong>注意</strong>: <code>LinkedList</code> 的API在某些操作上不如 <code>Vec</code> 或 <code>VecDeque</code> 直观，特别是涉及修改链表中间部分时。</li>
</ul>
<h3 id="4-HashMap-哈希映射"><a href="#4-HashMap-哈希映射" class="headerlink" title="4. HashMap&lt;K, V&gt; (哈希映射)"></a>4. <code>HashMap&lt;K, V&gt;</code> (哈希映射)</h3><ul>
<li><strong>概要与用途</strong>: <code>HashMap&lt;K, V&gt;</code> 存储键值对 (key-value pairs)。它使用哈希表实现，提供平均O(1)时间的插入、删除和查找操作。键 <code>K</code> 必须实现 <code>Eq</code> 和 <code>Hash</code> trait。<code>HashMap</code> 中的元素是无序的。</li>
<li><strong>内部实现</strong>: 基于哈希表，使用开放定址法或链地址法来解决哈希冲突。默认使用SipHash 1-3哈希算法，可以抵抗哈希洪水攻击。</li>
<li><strong>所有权</strong>: 本身不是 <code>Copy</code>。键和值的所有权会移入<code>HashMap</code>。</li>
<li><strong>主要操作与API</strong>:<ul>
<li><strong>创建</strong>: <code>HashMap::new()</code>, <code>HashMap::with_capacity(capacity: usize)</code>.</li>
<li><strong>插入&#x2F;更新</strong>: <code>insert(key: K, value: V) -&gt; Option&lt;V&gt;</code> (如果键已存在，返回旧值)。</li>
<li><strong>获取</strong>: <code>get(key: &amp;K) -&gt; Option&lt;&amp;V&gt;</code>, <code>get_mut(key: &amp;K) -&gt; Option&lt;&amp;mut V&gt;</code>.</li>
<li><strong>删除</strong>: <code>remove(key: &amp;K) -&gt; Option&lt;V&gt;</code>.</li>
<li><strong>检查存在性</strong>: <code>contains_key(key: &amp;K) -&gt; bool</code>.</li>
<li><strong>长度</strong>: <code>len()</code>, <code>is_empty()</code>.</li>
<li><strong>迭代</strong>: <code>iter()</code> (产生 <code>(&amp;K, &amp;V)</code>), <code>iter_mut()</code> (产生 <code>(&amp;K, &amp;mut V)</code>), <code>keys()</code> (产生 <code>&amp;K</code>), <code>values()</code> (产生 <code>&amp;V</code>), <code>into_iter()</code> (产生 <code>(K, V)</code>).</li>
<li><strong>Entry API</strong>: <code>entry(key: K) -&gt; Entry&lt;&#39;_, K, V&gt;</code> (提供更复杂的原子操作，如 <code>or_insert</code>, <code>and_modify</code> 等)。</li>
</ul>
</li>
<li><strong>性能特性</strong>:<ul>
<li>插入、删除、查找: 平均 O(1)，最坏 O(n) (哈希冲突严重时)。</li>
</ul>
</li>
<li><strong>键的要求</strong>: 类型 <code>K</code> 必须实现 <code>std::cmp::Eq</code> 和 <code>std::hash::Hash</code> trait。</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;<span class="type">String</span>, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>), <span class="number">100</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Bob&quot;</span>), <span class="number">95</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alice_score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(score) = alice_score &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Alice&#x27;s score: &#123;&#125;&quot;</span>, score); <span class="comment">// Alice&#x27;s score: 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Entry API 更新或插入</span></span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Charlie&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">80</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>)).<span class="title function_ invoke__">and_modify</span>(|s| *s += <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Scores: &#123;:?&#125;&quot;</span>, scores);</span><br><span class="line">    <span class="keyword">for</span> (name, score) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, name, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-BTreeMap-B树映射"><a href="#5-BTreeMap-B树映射" class="headerlink" title="5. BTreeMap&lt;K, V&gt; (B树映射)"></a>5. <code>BTreeMap&lt;K, V&gt;</code> (B树映射)</h3><ul>
<li><strong>概要与用途</strong>: <code>BTreeMap&lt;K, V&gt;</code> 也存储键值对，但它使用B树实现。与<code>HashMap</code>不同，<code>BTreeMap</code> 中的键值对是按键的顺序排序的。键 <code>K</code> 必须实现 <code>Ord</code> trait (通常也需要 <code>Eq</code> 和 <code>PartialOrd</code>)。</li>
<li><strong>内部实现</strong>: 基于B树，这是一种自平衡树结构，可以保持数据排序并允许高效的范围查询。</li>
<li><strong>所有权</strong>: 本身不是 <code>Copy</code>。</li>
<li><strong>主要操作与API</strong>: 与 <code>HashMap</code> 类似，但迭代器会按键的顺序产生元素。<ul>
<li><code>range(key_range: R) -&gt; Range&lt;&#39;_, K, V&gt;</code>: 获取指定范围内的键值对。</li>
</ul>
</li>
<li><strong>性能特性</strong>:<ul>
<li>插入、删除、查找: O(log n)。</li>
<li>比 <code>HashMap</code> 慢，但提供了有序遍历和更好的最坏情况性能。</li>
<li>由于数据在内存中更有序，有时缓存性能可能比 <code>HashMap</code> 好，特别是在迭代时。</li>
</ul>
</li>
<li><strong>键的要求</strong>: 类型 <code>K</code> 必须实现 <code>std::cmp::Ord</code> trait。</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: BTreeMap&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = BTreeMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素会按键排序</span></span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;map &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value); <span class="comment">// 1: a, 2: b, 3: c</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-HashSet-哈希集合"><a href="#6-HashSet-哈希集合" class="headerlink" title="6. HashSet&lt;T&gt; (哈希集合)"></a>6. <code>HashSet&lt;T&gt;</code> (哈希集合)</h3><ul>
<li><strong>概要与用途</strong>: <code>HashSet&lt;T&gt;</code> 存储唯一的元素，类似于数学中的集合。它使用哈希表实现，其元素是无序的。值 <code>T</code> 必须实现 <code>Eq</code> 和 <code>Hash</code> trait。</li>
<li><strong>内部实现</strong>: 通常基于 <code>HashMap&lt;T, ()&gt;</code> 实现。</li>
<li><strong>所有权</strong>: 本身不是 <code>Copy</code>。</li>
<li><strong>主要操作与API</strong>:<ul>
<li><strong>创建</strong>: <code>HashSet::new()</code>.</li>
<li><strong>添加</strong>: <code>insert(value: T) -&gt; bool</code> (如果值已存在则返回 <code>false</code>，否则返回 <code>true</code>)。</li>
<li><strong>删除</strong>: <code>remove(value: &amp;T) -&gt; bool</code> (如果值存在并被删除则返回 <code>true</code>)。</li>
<li><strong>检查存在性</strong>: <code>contains(value: &amp;T) -&gt; bool</code>.</li>
<li><strong>集合运算</strong>: <code>union()</code>, <code>intersection()</code>, <code>difference()</code>, <code>symmetric_difference()</code>.</li>
<li><strong>长度</strong>: <code>len()</code>, <code>is_empty()</code>.</li>
<li><strong>迭代</strong>: <code>iter()</code>, <code>into_iter()</code>.</li>
</ul>
</li>
<li><strong>性能特性</strong>: 与 <code>HashMap</code> 类似，平均 O(1) 的插入、删除、查找。</li>
<li><strong>值的要求</strong>: 类型 <code>T</code> 必须实现 <code>std::cmp::Eq</code> 和 <code>std::hash::Hash</code> trait。</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">books</span>: HashSet&lt;<span class="type">String</span>&gt; = HashSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    books.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;The Rust Programming Language&quot;</span>));</span><br><span class="line">    books.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Programming Rust&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> books.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;The Rust Programming Language&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found the book!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">set1</span>: HashSet&lt;_&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">set2</span>: HashSet&lt;_&gt; = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">cloned</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Union: &#123;:?&#125;&quot;</span>, set1.<span class="title function_ invoke__">union</span>(&amp;set2).collect::&lt;<span class="type">Vec</span>&lt;_&gt;&gt;());</span><br><span class="line">    <span class="comment">// Union: (顺序不保证) [1, 2, 3, 4] 或其他组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-BTreeSet-B树集合"><a href="#7-BTreeSet-B树集合" class="headerlink" title="7. BTreeSet&lt;T&gt; (B树集合)"></a>7. <code>BTreeSet&lt;T&gt;</code> (B树集合)</h3><ul>
<li><strong>概要与用途</strong>: <code>BTreeSet&lt;T&gt;</code> 也存储唯一的元素，但它使用B树实现，因此元素是按顺序排序的。值 <code>T</code> 必须实现 <code>Ord</code> trait。</li>
<li><strong>内部实现</strong>: 通常基于 <code>BTreeMap&lt;T, ()&gt;</code> 实现。</li>
<li><strong>所有权</strong>: 本身不是 <code>Copy</code>。</li>
<li><strong>主要操作与API</strong>: 与 <code>HashSet</code> 类似，但迭代器会按顺序产生元素。<ul>
<li>也支持集合运算。</li>
</ul>
</li>
<li><strong>性能特性</strong>: 与 <code>BTreeMap</code> 类似，O(log n) 的插入、删除、查找。</li>
<li><strong>值的要求</strong>: 类型 <code>T</code> 必须实现 <code>std::cmp::Ord</code> trait。</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BTreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span>: BTreeSet&lt;<span class="type">i32</span>&gt; = BTreeSet::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    numbers.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>);</span><br><span class="line">    numbers.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>);</span><br><span class="line">    numbers.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素会按顺序输出</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> &amp;numbers &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, num); <span class="comment">// 1, 2, 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-String-字符串"><a href="#8-String-字符串" class="headerlink" title="8. String (字符串)"></a>8. <code>String</code> (字符串)</h3><ul>
<li><strong>概要与用途</strong>: <code>String</code> 是一个可增长的、UTF-8编码的、在堆上分配的字符串类型。它是Rust中处理文本数据的主要方式。</li>
<li><strong>内部实现</strong>: <code>String</code> 内部本质上是一个 <code>Vec&lt;u8&gt;</code>，但它保证了其内容始终是有效的UTF-8编码。</li>
<li><strong>所有权</strong>: <code>String</code> 不是 <code>Copy</code>。赋值或函数传递会导致所有权转移。使用 <code>.clone()</code> 可以创建副本。</li>
<li><strong>主要操作与API</strong>: (非常多，这里列举一些)<ul>
<li><strong>创建</strong>: <code>String::new()</code>, <code>String::from(&quot;literal&quot;)</code>, <code>to_string()</code> 方法。</li>
<li><strong>追加</strong>: <code>push_str(s: &amp;str)</code>, <code>push(c: char)</code>, <code>+</code> 或 <code>+=</code> 操作符 (通常与 <code>&amp;str</code> 配合)。</li>
<li><strong>修改</strong>: <code>replace()</code>, <code>remove()</code>, <code>truncate()</code>, <code>clear()</code>.</li>
<li><strong>访问</strong>: <code>len()</code> (字节长度), <code>chars()</code> (迭代Unicode字符), <code>bytes()</code> (迭代字节), <code>get()</code> (获取子切片)。</li>
<li><strong>切片</strong>: 可以创建 <code>&amp;str</code> 类型的字符串切片。</li>
</ul>
</li>
<li><strong>性能特性</strong>: 许多操作与 <code>Vec&lt;u8&gt;</code> 类似。UTF-8字符操作可能比ASCII字符操作复杂。</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// hello, world!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;你好&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Length in bytes: &#123;&#125;&quot;</span>, s2.<span class="title function_ invoke__">len</span>()); <span class="comment">// 你好 (UTF-8) -&gt; 6 bytes</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Number of chars: &#123;&#125;&quot;</span>, s2.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">count</span>()); <span class="comment">// Number of chars: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-BinaryHeap-二叉堆-优先队列"><a href="#9-BinaryHeap-二叉堆-优先队列" class="headerlink" title="9. BinaryHeap&lt;T&gt; (二叉堆 &#x2F; 优先队列)"></a>9. <code>BinaryHeap&lt;T&gt;</code> (二叉堆 &#x2F; 优先队列)</h3><ul>
<li><strong>概要与用途</strong>: <code>BinaryHeap&lt;T&gt;</code> 是一个基于二叉堆实现的优先队列。默认情况下，它是一个最大堆，即 <code>pop()</code> 操作总是返回最大的元素。元素 <code>T</code> 必须实现 <code>Ord</code> trait。</li>
<li><strong>内部实现</strong>: 通常使用数组（<code>Vec</code>）来隐式表示堆结构。</li>
<li><strong>所有权</strong>: 本身不是 <code>Copy</code>。</li>
<li><strong>主要操作与API</strong>:<ul>
<li><strong>创建</strong>: <code>BinaryHeap::new()</code>.</li>
<li><strong>添加</strong>: <code>push(value: T)</code>.</li>
<li><strong>获取&#x2F;删除最大元素</strong>: <code>pop() -&gt; Option&lt;T&gt;</code>.</li>
<li><strong>查看最大元素</strong>: <code>peek() -&gt; Option&lt;&amp;T&gt;</code>.</li>
<li><strong>长度</strong>: <code>len()</code>, <code>is_empty()</code>.</li>
<li><strong>迭代</strong>: <code>iter()</code>, <code>into_iter_sorted()</code> (消耗堆并返回排序的迭代器)。</li>
</ul>
</li>
<li><strong>性能特性</strong>:<ul>
<li><code>push</code>: O(log n)。</li>
<li><code>pop</code>: O(log n)。</li>
<li><code>peek</code>: O(1)。</li>
</ul>
</li>
<li><strong>值的要求</strong>: 类型 <code>T</code> 必须实现 <code>std::cmp::Ord</code> (以及 <code>PartialOrd</code>, <code>Eq</code> 通常也需要)。</li>
<li><strong>示例</strong>:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::BinaryHeap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">heap</span> = BinaryHeap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    heap.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    heap.<span class="title function_ invoke__">push</span>(<span class="number">5</span>);</span><br><span class="line">    heap.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Peek: &#123;:?&#125;&quot;</span>, heap.<span class="title function_ invoke__">peek</span>()); <span class="comment">// Peek: Some(5)</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(val) = heap.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Popped: &#123;&#125;&quot;</span>, val); <span class="comment">// 5, 3, 1 (顺序)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>选择合适的集合类型取决于你的具体需求，如是否需要排序、是否需要唯一元素、访问模式、性能要求等。Rust的<code>std::collections</code>模块提供了丰富且高效的工具来满足各种场景。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jackey Zhou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/')">各种集合和数组</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=各种集合和数组&amp;url=http://example.com/2025/05/08/%E5%90%84%E7%A7%8D%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Welcome To LifeTech's Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Rust基础知识<span class="tagsPageCount">21</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/08/struct%E3%80%81trait%E5%92%8Cenum/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">struct、trait和enum</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/08/Copy%E5%92%8CMove/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Copy和Move</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/05/08/Copy%E5%92%8CMove/" title="Copy和Move"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Copy和Move</div></div></a></div><div><a href="/2025/05/08/FFI/" title="FFI"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">FFI</div></div></a></div><div><a href="/2025/05/08/Rust%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" title="Rust常用标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust常用标准库</div></div></a></div><div><a href="/2025/05/08/Rust%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" title="Rust常用第三方库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust常用第三方库</div></div></a></div><div><a href="/2025/05/08/Rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" title="Rust异步编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust异步编程</div></div></a></div><div><a href="/2025/05/08/Rust%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/" title="Rust综合案例"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust综合案例</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">记录技术成长的个人博客</div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Vec-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E5%90%91%E9%87%8F-Vector"><span class="toc-number">1.</span> <span class="toc-text">1. Vec&lt;T&gt; (动态数组&#x2F;向量 Vector)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-VecDeque-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-Vector-Deque"><span class="toc-number">2.</span> <span class="toc-text">2. VecDeque&lt;T&gt; (双端队列 Vector Deque)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LinkedList-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">3. LinkedList&lt;T&gt; (双向链表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HashMap-%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84"><span class="toc-number">4.</span> <span class="toc-text">4. HashMap&lt;K, V&gt; (哈希映射)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-BTreeMap-B%E6%A0%91%E6%98%A0%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text">5. BTreeMap&lt;K, V&gt; (B树映射)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HashSet-%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">6. HashSet&lt;T&gt; (哈希集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-BTreeSet-B%E6%A0%91%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">7. BTreeSet&lt;T&gt; (B树集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">8. String (字符串)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-BinaryHeap-%E4%BA%8C%E5%8F%89%E5%A0%86-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text">9. BinaryHeap&lt;T&gt; (二叉堆 &#x2F; 优先队列)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/Rust%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/" title="Rust综合案例">Rust综合案例</a><time datetime="2025-05-07T18:24:47.000Z" title="发表于 2025-05-08 02:24:47">2025-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/Rust%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" title="Rust常用第三方库">Rust常用第三方库</a><time datetime="2025-05-07T18:12:12.000Z" title="发表于 2025-05-08 02:12:12">2025-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/Rust%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" title="Rust常用标准库">Rust常用标准库</a><time datetime="2025-05-07T18:12:04.000Z" title="发表于 2025-05-08 02:12:04">2025-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/Rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" title="Rust异步编程">Rust异步编程</a><time datetime="2025-05-07T18:11:50.000Z" title="发表于 2025-05-08 02:11:50">2025-05-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/08/%E5%AE%8FMacros/" title="宏Macros">宏Macros</a><time datetime="2025-05-07T18:09:43.000Z" title="发表于 2025-05-08 02:09:43">2025-05-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Jackey Zhou" target="_blank">Jackey Zhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSharp%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">CSharp学习<sup>3</sup></a><a href="/tags/IDE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 0.88rem;">IDE常用快捷键<sup>2</sup></a><a href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">Rust基础知识<sup>21</sup></a><a href="/tags/docker%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">docker学习<sup>1</sup></a><a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">hexo博客常见命令<sup>1</sup></a><a href="/tags/xmake%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">xmake学习<sup>3</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">个人学习<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 0.88rem;">数据分析<sup>1</sup></a><a href="/tags/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/" style="font-size: 0.88rem;">无线调试<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">系统常用命令<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 0.88rem;">系统常用快捷键<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jackey Zhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>