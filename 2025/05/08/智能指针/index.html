<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>智能指针 | Welcome To LifeTech's Blog</title><meta name="keywords" content="Rust基础知识"><meta name="author" content="Jackey Zhou"><meta name="copyright" content="Jackey Zhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="智能指针"><meta name="application-name" content="智能指针"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="智能指针"><meta property="og:url" content="http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/index.html"><meta property="og:site_name" content="Welcome To LifeTech's Blog"><meta property="og:description" content="智能指针 (Smart Pointers) 是 Rust 中一个非常重要的概念，它们是行为上类似于指针，但还附带额外元数据和功能的数据结构。与普通引用不同，智能指针通常拥有它们指向的数据的所有权。Rust 标准库提供了多种智能指针，用于解决不同的问题，如管理堆上分配的内存、实现引用计数、提供内部可变"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Jackey Zhou"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="智能指针 (Smart Pointers) 是 Rust 中一个非常重要的概念，它们是行为上类似于指针，但还附带额外元数据和功能的数据结构。与普通引用不同，智能指针通常拥有它们指向的数据的所有权。Rust 标准库提供了多种智能指针，用于解决不同的问题，如管理堆上分配的内存、实现引用计数、提供内部可变"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jackey Zhou","link":"链接: ","source":"来源: Welcome To LifeTech's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Welcome To LifeTech's Blog',
  title: '智能指针',
  postAI: '',
  pageFillDescription: '1. Deref Trait 和 Deref 型强制 (Deref Coercion), 2. Drop Trait, 3. 主要的智能指针, a) BoxltTgt (盒子), b) RcltTgt (引用计数 x2F Reference Counting), c) ArcltTgt (原子引用计数 x2F Atomically Reference Counting), d) RefCellltTgt 与内部可变性 (Interior Mutability), e) MutexltTgt 和 RwLockltTgt (用于多线程的内部可变性), f) WeakltTgt (弱引用 x2F Weak Pointers), 总结智能指针是中一个非常重要的概念它们是行为上类似于指针但还附带额外元数据和功能的数据结构与普通引用不同智能指针通常拥有它们指向的数据的所有权标准库提供了多种智能指针用于解决不同的问题如管理堆上分配的内存实现引用计数提供内部可变性以及确保并发安全等理解智能指针的关键在于它们通常实现了和这两个和型强制允许你自定义解引用运算符的行为当为一个类型实现后你可以像使用普通引用一样使用该类型的实例一个简单的元组结构体关联类型指定解引用后得到的值的类型返回一个对内部数据的引用是元组结构体的第一个元素即类型的值在这里被解引用等同于因为返回所以得到类型的值如果没有型强制这里会报错因为期望或显式调用通过型强制被自动转换为然后到注意这里是型强制型强制是编译器提供的一种便利功能如果一个类型实现了那么类型的值对的引用在传递给函数或方法时可以被自动转换强制为类型的值这个过程可以递归地进行例如实现了所以可以被强制转换为如果实现了那么可以被强制转换为然后进一步被强制转换为这就是上面能够工作的原因允许你自定义当一个值离开作用域时应该执行的代码通常用于释放资源如内存文件句柄网络连接等这与中的析构函数或中的方法尽管行为有所不同类似是模式的核心当实例离开作用域时此方法会被自动调用和在这里离开作用域它们的方法会被调用顺序通常与创建顺序相反你不能显式调用方法但可以使用来提前销毁一个值如果需要提前输出大致顺序主要的智能指针盒子目的通常称为盒子允许你在堆上分配数据并拥有对该数据的唯一所有权当离开作用域时它所指向的堆数据会被释放通过用途处理编译时大小未知的数据例如在定义递归数据结构如链表或树时字段不能直接包含相同类型的结构体因为这会导致无限大小可以使用来存储递归部分递归部分用包装转移大量数据的所有权当你有大量数据并希望转移其所有权而不进行昂贵的复制操作时可以将数据放入中然后移动它本身很小只包含指向堆数据的指针特性对象当你想拥有一个实现了某个的类型的值但其具体类型在编译时未知或可能不同时通常会使用实现实现了指向和被分配在堆上实例在栈上并指向堆上的解引用来获取值离开作用域堆上的被释放引用计数目的允许多个所有者共享对同一块堆数据的只读访问它通过跟踪指向数据的引用数量来实现当最后一个指针被销毁引用计数变为零时数据才会被清理用途当你需要在程序的多个部分共享数据并且无法在编译时确定哪个部分会最后使用完数据时仅用于单线程场景因为它不是线程安全的创建一个新的这不是深拷贝数据而是克隆指针本身并增加引用计数实现实现了指向和减少引用计数注意默认只提供对其内部数据的不可变访问如果你需要修改内部的数据通常需要结合内部可变性模式例如循环引用可能会导致循环引用例如两个相互指向这会使得引用计数永远不会变为零从而导致内存泄漏可以使用来打破循环引用也指向克隆增加的引用计数克隆增加的引用计数因为还指向再次克隆增加的引用计数当离开作用域时它们各自对应的引用计数会减少原子引用计数目的是的线程安全版本它使用原子操作来管理引用计数因此可以在多个线程之间安全地共享所有权用途当你需要在多个线程中共享数据所有权时与非常相似实现实现了和为了在线程间传递通常需要满足和的约束注意与类似默认只提供不可变访问需要结合或来实现线程安全的内部可变性也可能发生循环引用需要来解决包装一个克隆增加引用计数的所有权被移动到新线程仍然是如果线程都结束了或者更多如果线程还在持有与内部可变性目的提供内部可变性模式即允许你在拥有对某个数据结构的不可变引用时仍然能够修改其内部的数据这与通常的借用规则编译时检查不同会在运行时检查借用规则如果违反规则例如同时存在多个可变借用程序会用途当你确定代码在运行时会遵守借用规则但编译器无法静态地验证它时在某些数据结构如图或回调函数中需要修改通过不可变引用访问到的数据仅用于单线程场景创建一个新的不可变地借用内部数据返回一个智能指针如果违反借用规则例如已存在可变借用则可变地借用内部数据返回一个智能指针如果违反借用规则例如已存在任何其他借用则和非版本返回和它们是实现了的智能指针确保借用在它们存在期间有效并在它们被时更新借用计数常见组合允许你拥有多个所有者并且每个所有者都可以在运行时借用规则的约束下修改内部数据注意这里是通常表示不可变允许在方法中修改是但我们可以通过修改获取可变借用如果这里同时有另一个处于活动状态或者有活动的则会获取不可变借用以打印和用于多线程的内部可变性目的和是用于在多线程环境中同步对共享数据的访问从而实现线程安全的内部可变性保证一次只有一个线程可以访问内部的数据方法会尝试获取锁如果锁已被其他线程持有当前线程会阻塞直到锁被释放返回一个是一个智能指针实现了和当离开作用域时自动释放锁如果一个持有锁的线程了会被认为是被污染后续对的调用会返回但你仍然可以通过来获取数据如果需要恢复允许多个线程同时读取数据通过获取读锁或者只允许一个线程写入数据通过获取写锁读锁可以共享写锁是独占的如果有活动的读锁写锁请求会阻塞如果持有写锁所有其他读锁或写锁请求都会阻塞常见组合或是在线程间共享和修改数据的标准模式允许多个线程拥有的所有权保证一次只有一个线程能访问内部的获取锁处理可能的实现了可以直接修改内部数据在这里离开作用域锁被自动释放主线程获取锁并打印最终结果弱引用目的是或对应的一种非拥有型引用它允许你引用一个由管理的值但不会增加强引用计数用途主要用于打破循环引用循环引用会导致的引用计数永远不会降到零从而造成内存泄漏从创建一个尝试将升级为一个临时的如果原始数据仍然存在强引用计数则返回如果数据已被销毁则返回注意必须先才能访问它指向的数据使用来持有对父节点的引用以避免循环引用初始时没有父节点将设置为的父节点创建对的弱引用强引用仍然是来自如果被销毁会返回总结智能指针是中管理内存和实现高级数据结构及并发模式的重要工具它们通过和提供了强大的抽象并与所有权系统紧密集成以保证内存安全和线程安全简单的堆分配和唯一所有权单线程共享所有权多线程共享所有权单线程内部可变性运行时借用检查多线程内部可变性通过锁同步与配合打破循环引用',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-08 02:00:04',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Welcome To LifeTech's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSharp%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">CSharp学习<sup>3</sup></a><a href="/tags/IDE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 1.05rem;">IDE常用快捷键<sup>2</sup></a><a href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">Rust基础知识<sup>21</sup></a><a href="/tags/csharp%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">csharp相关学习<sup>5</sup></a><a href="/tags/docker%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">docker学习<sup>1</sup></a><a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">hexo博客常见命令<sup>1</sup></a><a href="/tags/python%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">python相关学习<sup>4</sup></a><a href="/tags/tauri%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">tauri基础知识<sup>1</sup></a><a href="/tags/xmake%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">xmake学习<sup>3</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">个人学习<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">前端学习<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 1.05rem;">数据分析<sup>1</sup></a><a href="/tags/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/" style="font-size: 1.05rem;">无线调试<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size: 1.05rem;">系统常用命令<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 1.05rem;">系统常用快捷键<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">32</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Rust基础知识</span></a></span></div></div><h1 class="post-title" itemprop="name headline">智能指针</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-05-07T17:40:10.000Z" title="发表于 2025-05-08 01:40:10">2025-05-08</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-05-07T18:00:04.918Z" title="更新于 2025-05-08 02:00:04">2025-05-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为无锡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>无锡</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"><header><a href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url">Rust基础知识</a><h1 id="CrawlerTitle" itemprop="name headline">智能指针</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jackey Zhou</span><time itemprop="dateCreated datePublished" datetime="2025-05-07T17:40:10.000Z" title="发表于 2025-05-08 01:40:10">2025-05-08</time><time itemprop="dateCreated datePublished" datetime="2025-05-07T18:00:04.918Z" title="更新于 2025-05-08 02:00:04">2025-05-08</time></header><p>智能指针 (Smart Pointers) 是 Rust 中一个非常重要的概念，它们是行为上类似于指针，但还附带额外元数据和功能的数据结构。与普通引用不同，智能指针通常拥有它们指向的数据的所有权。Rust 标准库提供了多种智能指针，用于解决不同的问题，如管理堆上分配的内存、实现引用计数、提供内部可变性以及确保并发安全等。</p>
<p>理解智能指针的关键在于它们通常实现了 <code>Deref</code> 和 <code>Drop</code> 这两个 trait。</p>
<h3 id="1-Deref-Trait-和-Deref-型强制-Deref-Coercion"><a href="#1-Deref-Trait-和-Deref-型强制-Deref-Coercion" class="headerlink" title="1. Deref Trait 和 Deref 型强制 (Deref Coercion)"></a>1. <code>Deref</code> Trait 和 Deref 型强制 (Deref Coercion)</h3><p><code>Deref</code> trait 允许你自定义解引用运算符 <code>*</code> (dereference operator) 的行为。当为一个类型实现 <code>Deref</code> trait 后，你可以像使用普通引用一样使用该类型的实例。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T); <span class="comment">// 一个简单的元组结构体</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T; <span class="comment">// 关联类型，指定解引用后得到的值的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123; <span class="comment">// 返回一个对内部数据的引用</span></span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span> <span class="comment">// self.0 是元组结构体 MyBox&lt;T&gt; 的第一个元素，即 T 类型的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y); <span class="comment">// *y 在这里被解引用，等同于 *(y.deref())</span></span><br><span class="line">                       <span class="comment">// 因为 y.deref() 返回 &amp;i32，所以 *y 得到 i32 类型的值 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">// greet(&amp;m); // 如果没有 Deref 型强制，这里会报错，因为 greet 期望 &amp;String 或 &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">greet_explicit</span>(m.<span class="title function_ invoke__">deref</span>()); <span class="comment">// 显式调用 deref</span></span><br><span class="line">    <span class="title function_ invoke__">greet_coerced</span>(&amp;m); <span class="comment">// 通过 Deref 型强制，&amp;MyBox&lt;String&gt; 被自动转换为 &amp;String，然后到 &amp;str</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet_explicit</span>(name: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;! (explicit deref)&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet_coerced</span>(name: &amp;<span class="type">str</span>) &#123; <span class="comment">// 注意这里是 &amp;str</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;! (coerced)&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Deref 型强制 (Deref Coercion)</strong>:<br>Deref 型强制是 Rust 编译器提供的一种便利功能。如果一个类型 <code>U</code> 实现了 <code>Deref&lt;Target=T&gt;</code> trait，那么 <code>&amp;U</code> 类型的值（对 <code>U</code> 的引用）在传递给函数或方法时，可以被自动转换（强制）为 <code>&amp;T</code> 类型的值。这个过程可以递归地进行。</p>
<p>例如，<code>String</code> 实现了 <code>Deref&lt;Target=str&gt;</code>，所以 <code>&amp;String</code> 可以被强制转换为 <code>&amp;str</code>。如果 <code>MyBox&lt;String&gt;</code> 实现了 <code>Deref&lt;Target=String&gt;</code>，那么 <code>&amp;MyBox&lt;String&gt;</code> 可以被强制转换为 <code>&amp;String</code>，然后进一步被强制转换为 <code>&amp;str</code>。这就是上面 <code>greet_coerced(&amp;m)</code> 能够工作的原因。</p>
<h3 id="2-Drop-Trait"><a href="#2-Drop-Trait" class="headerlink" title="2. Drop Trait"></a>2. <code>Drop</code> Trait</h3><p><code>Drop</code> trait 允许你自定义当一个值离开作用域时应该执行的代码，通常用于释放资源，如内存、文件句柄、网络连接等。这与 C++ 中的析构函数或 Java 中的 <code>finalize</code> 方法（尽管行为有所不同）类似，是 RAII (Resource Acquisition Is Initialization) 模式的核心。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="comment">// 当 CustomSmartPointer 实例离开作用域时，此方法会被自动调用</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123; data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;my stuff&quot;</span>) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer &#123; data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;other stuff&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointers created.&quot;</span>);</span><br><span class="line">    <span class="comment">// c 和 d 在这里离开作用域，它们的 drop 方法会被调用 (顺序通常与创建顺序相反)</span></span><br><span class="line">    <span class="comment">// 你不能显式调用 drop 方法 (c.drop())，但可以使用 std::mem::drop 来提前销毁一个值。</span></span><br><span class="line">    <span class="comment">// drop(c); // 如果需要提前 drop c</span></span><br><span class="line">    <span class="comment">// println!(&quot;c was dropped before the end of main&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 (大致顺序):</span></span><br><span class="line"><span class="comment">// CustomSmartPointers created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></table></figure>

<h3 id="3-主要的智能指针"><a href="#3-主要的智能指针" class="headerlink" title="3. 主要的智能指针"></a>3. 主要的智能指针</h3><h4 id="a-Box-盒子"><a href="#a-Box-盒子" class="headerlink" title="a) Box&lt;T&gt; (盒子)"></a>a) <code>Box&lt;T&gt;</code> (盒子)</h4><ul>
<li><strong>目的</strong>: <code>Box&lt;T&gt;</code>（通常称为“盒子”）允许你在<strong>堆 (heap)</strong> 上分配数据，并拥有对该数据的唯一所有权。当 <code>Box&lt;T&gt;</code> 离开作用域时，它所指向的堆数据会被释放（通过 <code>Drop</code> trait）。</li>
<li><strong>用途</strong>:<ol>
<li><strong>处理编译时大小未知的数据</strong>: 例如，在定义递归数据结构（如链表或树）时，字段不能直接包含相同类型的结构体，因为这会导致无限大小。可以使用 <code>Box</code> 来存储递归部分。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;), <span class="comment">// 递归部分用 Box 包装</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>转移大量数据的所有权</strong>: 当你有大量数据并希望转移其所有权而不进行昂贵的复制操作时，可以将数据放入 <code>Box</code> 中，然后移动 <code>Box</code>（它本身很小，只包含指向堆数据的指针）。</li>
<li><strong>Trait Objects (特性对象)</strong>: 当你想拥有一个实现了某个 trait 的类型的值，但其具体类型在编译时未知或可能不同时，通常会使用 <code>Box&lt;dyn TraitName&gt;</code>。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123; <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Button</span> &#123; id: <span class="type">u32</span> &#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123; <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123; <span class="built_in">println!</span>(<span class="string">&quot;Drawing button &#123;&#125;&quot;</span>, <span class="keyword">self</span>.id); &#125; &#125;</span><br><span class="line"><span class="comment">// let drawable: Box&lt;dyn Draw&gt; = Box::new(Button &#123; id: 1 &#125;);</span></span><br><span class="line"><span class="comment">// drawable.draw();</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><strong>实现</strong>: <code>Box&lt;T&gt;</code> 实现了 <code>Deref</code>（指向 <code>T</code>）和 <code>Drop</code>。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>); <span class="comment">// 5 被分配在堆上，b (Box 实例) 在栈上，并指向堆上的 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>, *b); <span class="comment">// 解引用 Box 来获取值</span></span><br><span class="line">&#125; <span class="comment">// b 离开作用域，堆上的 5 被释放</span></span><br></pre></td></tr></table></figure>

<h4 id="b-Rc-引用计数-Reference-Counting"><a href="#b-Rc-引用计数-Reference-Counting" class="headerlink" title="b) Rc&lt;T&gt; (引用计数 &#x2F; Reference Counting)"></a>b) <code>Rc&lt;T&gt;</code> (引用计数 &#x2F; Reference Counting)</h4><ul>
<li><strong>目的</strong>: <code>Rc&lt;T&gt;</code>（Reference Counted）允许多个“所有者”共享对同一块堆数据的只读访问。它通过跟踪指向数据的引用数量来实现。当最后一个 <code>Rc&lt;T&gt;</code> 指针被销毁（引用计数变为零）时，数据才会被清理。</li>
<li><strong>用途</strong>: 当你需要在程序的多个部分共享数据，并且无法在编译时确定哪个部分会最后使用完数据时。**<code>Rc&lt;T&gt;</code> 仅用于单线程场景**，因为它不是线程安全的。</li>
<li><strong>API</strong>:<ul>
<li><code>Rc::new(value: T)</code>: 创建一个新的 <code>Rc&lt;T&gt;</code>。</li>
<li><code>Rc::clone(rc_instance: &amp;Rc&lt;T&gt;)</code>: <strong>这不是深拷贝数据</strong>，而是克隆 <code>Rc&lt;T&gt;</code> 指针本身，并增加引用计数。</li>
</ul>
</li>
<li><strong>实现</strong>: <code>Rc&lt;T&gt;</code> 实现了 <code>Deref</code> (指向 <code>T</code>) 和 <code>Drop</code> (减少引用计数)。</li>
<li><strong>注意</strong>: <code>Rc&lt;T&gt;</code> 默认只提供对其内部数据的不可变访问。如果你需要修改 <code>Rc&lt;T&gt;</code> 内部的数据，通常需要结合内部可变性模式，例如 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>。</li>
<li><strong>循环引用</strong>: <code>Rc&lt;T&gt;</code> 可能会导致循环引用（例如，两个 <code>Rc</code> 相互指向），这会使得引用计数永远不会变为零，从而导致内存泄漏。可以使用 <code>Weak&lt;T&gt;</code> 来打破循环引用。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ListWithRc</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;ListWithRc&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> ListWithRc::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// a -&gt; (10, b)</span></span><br><span class="line">    <span class="comment">// b -&gt; (5, c)</span></span><br><span class="line">    <span class="comment">// c -&gt; (3, Nil)</span></span><br><span class="line">    <span class="comment">// d -&gt; (7, c) (也指向 c)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;c))); <span class="comment">// 克隆 Rc&lt;ListWithRc&gt; (c)，增加 c 的引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;b))); <span class="comment">// 克隆 b，增加 b 的引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b)); <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count of c after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c)); <span class="comment">// 2 (因为 b 还指向 c)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">7</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;c))); <span class="comment">// 再次克隆 c，增加 c 的引用计数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count of c after creating d = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 a, b, d 离开作用域时，它们各自对应的引用计数会减少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="c-Arc-原子引用计数-Atomically-Reference-Counting"><a href="#c-Arc-原子引用计数-Atomically-Reference-Counting" class="headerlink" title="c) Arc&lt;T&gt; (原子引用计数 &#x2F; Atomically Reference Counting)"></a>c) <code>Arc&lt;T&gt;</code> (原子引用计数 &#x2F; Atomically Reference Counting)</h4><ul>
<li><strong>目的</strong>: <code>Arc&lt;T&gt;</code> 是 <code>Rc&lt;T&gt;</code> 的线程安全版本。它使用原子操作来管理引用计数，因此可以在多个线程之间安全地共享所有权。</li>
<li><strong>用途</strong>: 当你需要在多个线程中共享数据所有权时。</li>
<li><strong>API</strong>: 与 <code>Rc&lt;T&gt;</code> 非常相似 (<code>Arc::new</code>, <code>Arc::clone</code>)。</li>
<li><strong>实现</strong>: <code>Arc&lt;T&gt;</code> 实现了 <code>Deref</code> 和 <code>Drop</code>。为了在线程间传递，<code>T</code> 通常需要满足 <code>Send</code> 和 <code>Sync</code> trait 的约束。</li>
<li><strong>注意</strong>: 与 <code>Rc&lt;T&gt;</code> 类似，默认只提供不可变访问，需要结合 <code>Mutex&lt;T&gt;</code> 或 <code>RwLock&lt;T&gt;</code> 来实现线程安全的内部可变性。也可能发生循环引用，需要 <code>std::sync::Weak&lt;T&gt;</code> 来解决。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Arc::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// Arc 包装一个 Vec</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">data_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;data); <span class="comment">// 克隆 Arc，增加引用计数</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="comment">// data_clone 的所有权被移动到新线程</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Thread &#123;&#125; sees data at index 2: &#123;&#125;&quot;</span>, i, data_clone[<span class="number">2</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Original data count: &#123;&#125;&quot;</span>, Arc::<span class="title function_ invoke__">strong_count</span>(&amp;data)); <span class="comment">// 仍然是 1 (如果线程都结束了)</span></span><br><span class="line">                                                                 <span class="comment">// 或者更多，如果线程还在持有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="d-RefCell-与内部可变性-Interior-Mutability"><a href="#d-RefCell-与内部可变性-Interior-Mutability" class="headerlink" title="d) RefCell&lt;T&gt; 与内部可变性 (Interior Mutability)"></a>d) <code>RefCell&lt;T&gt;</code> 与内部可变性 (Interior Mutability)</h4><ul>
<li><strong>目的</strong>: <code>RefCell&lt;T&gt;</code> 提供<strong>内部可变性</strong>模式，即允许你在拥有对某个数据结构的不可变引用时，仍然能够修改其内部的数据。这与 Rust 通常的借用规则（编译时检查）不同，<code>RefCell&lt;T&gt;</code> 会在<strong>运行时</strong>检查借用规则。如果违反规则（例如，同时存在多个可变借用），程序会 <code>panic!</code>。</li>
<li><strong>用途</strong>:<ul>
<li>当你确定代码在运行时会遵守借用规则，但编译器无法静态地验证它时。</li>
<li>在某些数据结构（如图）或回调函数中，需要修改通过不可变引用访问到的数据。</li>
<li><strong>仅用于单线程场景</strong>。</li>
</ul>
</li>
<li><strong>API</strong>:<ul>
<li><code>RefCell::new(value: T)</code>: 创建一个新的 <code>RefCell&lt;T&gt;</code>。</li>
<li><code>borrow(&amp;self) -&gt; Ref&lt;T&gt;</code>: 不可变地借用内部数据。返回一个 <code>Ref&lt;T&gt;</code> 智能指针。如果违反借用规则（例如，已存在可变借用），则 <code>panic!</code>。</li>
<li><code>borrow_mut(&amp;self) -&gt; RefMut&lt;T&gt;</code>: 可变地借用内部数据。返回一个 <code>RefMut&lt;T&gt;</code> 智能指针。如果违反借用规则（例如，已存在任何其他借用），则 <code>panic!</code>。</li>
<li><code>try_borrow(&amp;self) -&gt; Result&lt;Ref&lt;T&gt;, BorrowError&gt;</code> 和 <code>try_borrow_mut(&amp;self) -&gt; Result&lt;RefMut&lt;T&gt;, BorrowMutError&gt;</code>: 非 panic 版本，返回 <code>Result</code>。</li>
</ul>
</li>
<li><strong><code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code></strong>: 它们是实现了 <code>Deref</code> 的智能指针，确保借用在它们存在期间有效，并在它们被 <code>drop</code> 时更新借用计数。</li>
<li><strong>常见组合</strong>: <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> 允许你拥有多个所有者，并且每个所有者都可以（在运行时借用规则的约束下）修改内部数据。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>); <span class="comment">// 注意这里是 &amp;self，通常表示不可变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;, <span class="comment">// RefCell 允许在 &amp;self 方法中修改 messages</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MessageQueue &#123;</span><br><span class="line">        MessageQueue &#123; messages: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="comment">// self 是 &amp;MessageQueue，但我们可以通过 RefCell 修改 messages</span></span><br><span class="line">        <span class="keyword">self</span>.messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(msg)); <span class="comment">// 获取可变借用</span></span><br><span class="line">        <span class="comment">// 如果这里同时有另一个 borrow_mut() 处于活动状态，或者有活动的 borrow()，则会 panic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">queue</span> = MessageQueue::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    queue.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Hello from RefCell!&quot;</span>);</span><br><span class="line">    queue.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Another message.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Messages in queue: &#123;:?&#125;&quot;</span>, queue.messages.<span class="title function_ invoke__">borrow</span>()); <span class="comment">// 获取不可变借用以打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="e-Mutex-和-RwLock-用于多线程的内部可变性"><a href="#e-Mutex-和-RwLock-用于多线程的内部可变性" class="headerlink" title="e) Mutex&lt;T&gt; 和 RwLock&lt;T&gt; (用于多线程的内部可变性)"></a>e) <code>Mutex&lt;T&gt;</code> 和 <code>RwLock&lt;T&gt;</code> (用于多线程的内部可变性)</h4><ul>
<li><strong>目的</strong>: <code>Mutex&lt;T&gt;</code> (Mutual Exclusion) 和 <code>RwLock&lt;T&gt;</code> (Read-Write Lock) 是用于在<strong>多线程</strong>环境中同步对共享数据的访问，从而实现线程安全的内部可变性。</li>
<li><strong><code>Mutex&lt;T&gt;</code></strong>:<ul>
<li>保证一次只有一个线程可以访问 <code>Mutex&lt;T&gt;</code> 内部的数据。</li>
<li><code>lock()</code> 方法会尝试获取锁。如果锁已被其他线程持有，当前线程会阻塞，直到锁被释放。</li>
<li><code>lock()</code> 返回一个 <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>。<code>MutexGuard&lt;T&gt;</code> 是一个智能指针，实现了 <code>Deref</code> 和 <code>Drop</code>（当 <code>MutexGuard</code> 离开作用域时自动释放锁）。</li>
<li><strong>Poisoning</strong>: 如果一个持有锁的线程 <code>panic!</code> 了，<code>Mutex</code> 会被认为是“被污染 (poisoned)”。后续对 <code>lock()</code> 的调用会返回 <code>Err</code>，但你仍然可以通过 <code>into_inner()</code> 来获取数据（如果需要恢复）。</li>
</ul>
</li>
<li><strong><code>RwLock&lt;T&gt;</code></strong>:<ul>
<li>允许多个线程同时读取数据（通过 <code>read()</code> 获取读锁），或者只允许一个线程写入数据（通过 <code>write()</code> 获取写锁）。</li>
<li>读锁可以共享，写锁是独占的。</li>
<li>如果有活动的读锁，写锁请求会阻塞。如果持有写锁，所有其他读锁或写锁请求都会阻塞。</li>
</ul>
</li>
<li><strong>常见组合</strong>: <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 或 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> 是在线程间共享和修改数据的标准模式。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Arc 允许多个线程拥有 Mutex 的所有权</span></span><br><span class="line">    <span class="comment">// Mutex 保证一次只有一个线程能访问内部的 i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter_clone.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>(); <span class="comment">// 获取锁，unwrap 处理可能的 PoisonError</span></span><br><span class="line">            *num += <span class="number">1</span>; <span class="comment">// MutexGuard 实现了 DerefMut，可以直接修改内部数据</span></span><br><span class="line">        &#125;); <span class="comment">// num (MutexGuard) 在这里离开作用域，锁被自动释放</span></span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()); <span class="comment">// 主线程获取锁并打印最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="f-Weak-弱引用-Weak-Pointers"><a href="#f-Weak-弱引用-Weak-Pointers" class="headerlink" title="f) Weak&lt;T&gt; (弱引用 &#x2F; Weak Pointers)"></a>f) <code>Weak&lt;T&gt;</code> (弱引用 &#x2F; Weak Pointers)</h4><ul>
<li><strong>目的</strong>: <code>Weak&lt;T&gt;</code> 是 <code>Rc&lt;T&gt;</code> (或 <code>std::sync::Weak&lt;T&gt;</code> 对应 <code>Arc&lt;T&gt;</code>) 的一种非拥有型引用。它允许你引用一个由 <code>Rc</code>&#x2F;<code>Arc</code> 管理的值，但<strong>不会增加强引用计数</strong>。</li>
<li><strong>用途</strong>: 主要用于**打破循环引用 (reference cycles)**。循环引用会导致 <code>Rc</code>&#x2F;<code>Arc</code> 的引用计数永远不会降到零，从而造成内存泄漏。</li>
<li><strong>API</strong>:<ul>
<li><code>Rc::downgrade(rc_instance: &amp;Rc&lt;T&gt;) -&gt; Weak&lt;T&gt;</code>: 从 <code>Rc&lt;T&gt;</code> 创建一个 <code>Weak&lt;T&gt;</code>。</li>
<li><code>upgrade(&amp;self) -&gt; Option&lt;Rc&lt;T&gt;&gt;</code>: 尝试将 <code>Weak&lt;T&gt;</code> 升级为一个临时的 <code>Rc&lt;T&gt;</code>。如果原始数据仍然存在（强引用计数 &gt; 0），则返回 <code>Some(Rc&lt;T&gt;)</code>；如果数据已被销毁，则返回 <code>None</code>。</li>
</ul>
</li>
<li><strong>注意</strong>: 必须先 <code>upgrade()</code> <code>Weak&lt;T&gt;</code> 才能访问它指向的数据。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    <span class="comment">// 使用 Weak&lt;Node&gt; 来持有对父节点的引用，以避免循环引用</span></span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()), <span class="comment">// 初始时没有父节点</span></span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>()); <span class="comment">// None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 branch 设置为 leaf 的父节点</span></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch); <span class="comment">// 创建对 branch 的弱引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf), Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf)); <span class="comment">// leaf 强引用仍然是1 (来自 branch.children)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf&#x27;s parent now = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>().<span class="title function_ invoke__">map</span>(|p| p.value)); <span class="comment">// Some(5)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 branch 被销毁，leaf.parent.borrow().upgrade() 会返回 None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>智能指针是 Rust 中管理内存和实现高级数据结构及并发模式的重要工具。它们通过 <code>Deref</code> 和 <code>Drop</code> trait 提供了强大的抽象，并与所有权系统紧密集成，以保证内存安全和线程安全。</p>
<ul>
<li><code>Box&lt;T&gt;</code>: 简单的堆分配和唯一所有权。</li>
<li><code>Rc&lt;T&gt;</code>: 单线程共享所有权。</li>
<li><code>Arc&lt;T&gt;</code>: 多线程共享所有权。</li>
<li><code>RefCell&lt;T&gt;</code>: 单线程内部可变性（运行时借用检查）。</li>
<li><code>Mutex&lt;T&gt;</code> &#x2F; <code>RwLock&lt;T&gt;</code>: 多线程内部可变性（通过锁同步）。</li>
<li><code>Weak&lt;T&gt;</code>: 与 <code>Rc</code>&#x2F;<code>Arc</code> 配合打破循环引用。</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jackey Zhou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/')">智能指针</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=智能指针&amp;url=http://example.com/2025/05/08/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Welcome To LifeTech's Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Rust基础知识<span class="tagsPageCount">21</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/08/%E9%97%AD%E5%8C%85%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">闭包和迭代器</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/08/%E5%B9%B6%E5%8F%91/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">并发</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/05/08/Copy%E5%92%8CMove/" title="Copy和Move"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Copy和Move</div></div></a></div><div><a href="/2025/05/08/FFI/" title="FFI"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">FFI</div></div></a></div><div><a href="/2025/05/08/Rust%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" title="Rust常用标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust常用标准库</div></div></a></div><div><a href="/2025/05/08/Rust%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" title="Rust常用第三方库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust常用第三方库</div></div></a></div><div><a href="/2025/05/08/Rust%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" title="Rust异步编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust异步编程</div></div></a></div><div><a href="/2025/05/08/Rust%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B/" title="Rust综合案例"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-05-08</div><div class="title">Rust综合案例</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description">记录技术成长的个人博客</div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Deref-Trait-%E5%92%8C-Deref-%E5%9E%8B%E5%BC%BA%E5%88%B6-Deref-Coercion"><span class="toc-number">1.</span> <span class="toc-text">1. Deref Trait 和 Deref 型强制 (Deref Coercion)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Drop-Trait"><span class="toc-number">2.</span> <span class="toc-text">2. Drop Trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BB%E8%A6%81%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.</span> <span class="toc-text">3. 主要的智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-Box-%E7%9B%92%E5%AD%90"><span class="toc-number">3.1.</span> <span class="toc-text">a) Box&lt;T&gt; (盒子)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-Rc-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-Reference-Counting"><span class="toc-number">3.2.</span> <span class="toc-text">b) Rc&lt;T&gt; (引用计数 &#x2F; Reference Counting)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-Arc-%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-Atomically-Reference-Counting"><span class="toc-number">3.3.</span> <span class="toc-text">c) Arc&lt;T&gt; (原子引用计数 &#x2F; Atomically Reference Counting)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-RefCell-%E4%B8%8E%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7-Interior-Mutability"><span class="toc-number">3.4.</span> <span class="toc-text">d) RefCell&lt;T&gt; 与内部可变性 (Interior Mutability)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e-Mutex-%E5%92%8C-RwLock-%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.5.</span> <span class="toc-text">e) Mutex&lt;T&gt; 和 RwLock&lt;T&gt; (用于多线程的内部可变性)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#f-Weak-%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-Pointers"><span class="toc-number">3.6.</span> <span class="toc-text">f) Weak&lt;T&gt; (弱引用 &#x2F; Weak Pointers)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/15/tauri%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/" title="tauri前后端交互">tauri前后端交互</a><time datetime="2025-05-14T16:28:49.000Z" title="发表于 2025-05-15 00:28:49">2025-05-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/12/vue3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="vue3基础知识">vue3基础知识</a><time datetime="2025-05-12T15:28:53.000Z" title="发表于 2025-05-12 23:28:53">2025-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/12/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/" title="模型部署">模型部署</a><time datetime="2025-05-11T18:17:36.000Z" title="发表于 2025-05-12 02:17:36">2025-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/12/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="数据科学与机器学习">数据科学与机器学习</a><time datetime="2025-05-11T18:17:28.000Z" title="发表于 2025-05-12 02:17:28">2025-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/12/pytorch%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="pytorch基础知识">pytorch基础知识</a><time datetime="2025-05-11T18:17:15.000Z" title="发表于 2025-05-12 02:17:15">2025-05-12</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Jackey Zhou" target="_blank">Jackey Zhou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSharp%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">CSharp学习<sup>3</sup></a><a href="/tags/IDE%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 0.88rem;">IDE常用快捷键<sup>2</sup></a><a href="/tags/Rust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">Rust基础知识<sup>21</sup></a><a href="/tags/csharp%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">csharp相关学习<sup>5</sup></a><a href="/tags/docker%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">docker学习<sup>1</sup></a><a href="/tags/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">hexo博客常见命令<sup>1</sup></a><a href="/tags/python%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">python相关学习<sup>4</sup></a><a href="/tags/tauri%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">tauri基础知识<sup>1</sup></a><a href="/tags/xmake%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">xmake学习<sup>3</sup></a><a href="/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">个人学习<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">前端学习<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size: 0.88rem;">数据分析<sup>1</sup></a><a href="/tags/%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95/" style="font-size: 0.88rem;">无线调试<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" style="font-size: 0.88rem;">系统常用命令<sup>2</sup></a><a href="/tags/%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" style="font-size: 0.88rem;">系统常用快捷键<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jackey Zhou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>